#!/bin/sh


#############################################################################
### Configuration

### Command paths (full or relative path possible)

### Preferences

# [Optional] Turns on debugging
DEBUG=1

### End of configuration
#############################################################################


#############################################################################
### Init

arg0="${0##*/}"

### Usage

usage()
{
  cat <<END >&2
Usage: $arg0 [-h] [-d dummy] [file...]
       -h: get help
       -d dummy: you're a dummy
END
  exit 1
}

### Option defaults

opt_dummy=

### Multiplex invocation mode

case "$arg0" in 
  dummy)
    opt_dummy=1
    ;;
  *)
    echo "FATAL ERROR: unrecognized invocation alias: $arg0"
    exit 2
    ;;
esac

### Options

opts=`getopt -o had: -n "$arg0" -- "$@"`
[ $? != 0 ] && usage
eval set -- "$opts"

while true; do
  case "$1" in
    -h) usage ;;
    -a) opt_arg="$2"; shift 2 ;;
    -d) opt_dummy=1; shift ;;
    --) shift ; break ;;
  esac
done


# Check that all arguments have been specified
# TODO: implement in sh
#(( $+opt_dummy != 1 )) && usage


#############################################################################
### Functions

cleanup()
{
  echo -en "\rCleaning up..." >/dev/tty

  trap - 1 2 3 15


  # Clear the Cleaning... line
  echo -en "\r              \r" >/dev/tty

  # FIXME: Don't know why $1 doesn't hold the signal number.
  # exit_code is workaround
  exit $exit_code
}

### Function Init

# Ensure a cleanup upon exit
exit_code=1
trap cleanup 1 2 3 15


#############################################################################
### Main


#############################################################################
### Done

exit_code=0


### Local Variables:
### coding: utf-8
### End:
### vim:set ai et sts=2 sw=2 tw=0 fileencoding=utf-8:
